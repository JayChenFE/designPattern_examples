### **效果及实现要点**

- 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达到松耦合。
- 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。观察者自己决定是否需要订阅通知。目标对象对此一无所知。
- 在C#中的Event和委托充当了抽象的Observer接口，而提供事件的对象充当了目标对象，委托是比抽象Observer接口更为松耦合的设计。

## **适用性**

- 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。

- 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。

- 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。

  ​

## 缺点

- 观察者模式需要考虑一下开发效率和运行效率问题，创建观察者和被观察者本身要消耗一定的内存和时间

- 观察者模式弱化了对象间的联系,实现了解耦,但是如果过度使用的话,对象和对象之间的必要联系也将深埋在背后,会导致程序难以跟踪维护和理解,比如:

  比如，我们去打猎，打死了一只母鹿，母鹿有三个幼崽，因失去了母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉，生存下来的秃鹰，则因此扩大了地盘……这就是一个触发机制，形成了一个触发链。观察者模式可以完美地实现这里的链条形式。

  这个例子里,中间的对象同时是观察者也是被观察者,消息通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。